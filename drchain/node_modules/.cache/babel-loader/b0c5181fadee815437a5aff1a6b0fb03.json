{"ast":null,"code":"import _defineProperty from 'babel-runtime/helpers/defineProperty';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* eslint-disable react/prop-types */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar Range = function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  function Range(props) {\n    _classCallCheck(this, Range);\n\n    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, props));\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _this.trimAlignValue(v, i);\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n\n  _createClass(Range, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n\n      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;\n\n      if (this.props.min === nextProps.min && this.props.max === nextProps.max && shallowEqual(this.props.value, nextProps.value)) {\n        return;\n      }\n\n      var bounds = this.state.bounds;\n      var value = nextProps.value || bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _this2.trimAlignValue(v, i, nextProps);\n      });\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\n        return v === bounds[i];\n      })) return;\n      this.setState({\n        bounds: nextBounds\n      });\n\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, nextProps);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, nextProps);\n        });\n        this.props.onChange(newValues);\n      }\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends({}, this.state, state);\n\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: 'onStart',\n    value: function onStart(position) {\n      var props = this.props;\n      var state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: 'onMove',\n    value: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var state = this.state;\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: 'onKeyboard',\n    value: function onKeyboard(e) {\n      var valueMutator = utils.getKeyboardValueMutator(e);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n        var value = this.trimAlignValue(mutatedValue);\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: 'getClosestBound',\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    }\n  }, {\n    key: 'getBoundNeedMoving',\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _state = this.state,\n          bounds = _state.bounds,\n          recent = _state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    }\n  }, {\n    key: 'getLowerBound',\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: 'getUpperBound',\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: 'getPoints',\n    value: function getPoints() {\n      var _props = this.props,\n          marks = _props.marks,\n          step = _props.step,\n          min = _props.min,\n          max = _props.max;\n      var cache = this._getPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this._getPointsCache.points;\n    }\n  }, {\n    key: 'moveTo',\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: 'pushSurroundingHandles',\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.props.pushable;\n      threshold = Number(threshold);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: 'pushHandle',\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    }\n  }, {\n    key: 'pushHandleOnePoint',\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.props.pushable;\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: 'trimAlignValue',\n    value: function trimAlignValue(v, handle) {\n      var nextProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var mergedProps = _extends({}, this.props, nextProps);\n\n      var valInRange = utils.ensureValueInRange(v, mergedProps);\n      var valNotConflict = this.ensureValueNotConflict(handle, valInRange, mergedProps);\n      return utils.ensureValuePrecision(valNotConflict, mergedProps);\n    }\n  }, {\n    key: 'ensureValueNotConflict',\n    value: function ensureValueNotConflict(handle, val, _ref) {\n      var allowCross = _ref.allowCross,\n          thershold = _ref.pushable;\n      var state = this.state || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.handle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n\n\n      return val;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var _state2 = this.state,\n          handle = _state2.handle,\n          bounds = _state2.bounds;\n      var _props2 = this.props,\n          prefixCls = _props2.prefixCls,\n          vertical = _props2.vertical,\n          included = _props2.included,\n          disabled = _props2.disabled,\n          min = _props2.min,\n          max = _props2.max,\n          handleGenerator = _props2.handle,\n          trackStyle = _props2.trackStyle,\n          handleStyle = _props2.handleStyle,\n          tabIndex = _props2.tabIndex;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = prefixCls + '-handle';\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var _tabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          _tabIndex = null;\n        }\n\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, handleClassName + '-' + (i + 1), true), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: handle === i,\n          index: i,\n          tabIndex: _tabIndex,\n          min: min,\n          max: max,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          }\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, prefixCls + '-track', true), _defineProperty(_classNames2, prefixCls + '-track-' + i, true), _classNames2));\n        return React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n\nRange.displayName = 'Range';\nRange.propTypes = {\n  autoFocus: PropTypes.bool,\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  allowCross: PropTypes.bool,\n  disabled: PropTypes.bool,\n  tabIndex: PropTypes.arrayOf(PropTypes.number),\n  min: PropTypes.number,\n  max: PropTypes.number\n};\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  tabIndex: []\n};\nexport default createSlider(Range);","map":{"version":3,"sources":["/Users/administrator/Desktop/DrChain/drchain_frontend/drchain/node_modules/rc-slider/es/Range.js"],"names":["_defineProperty","_extends","_toConsumableArray","_classCallCheck","_createClass","_possibleConstructorReturn","_inherits","React","PropTypes","classNames","shallowEqual","Track","createSlider","utils","Range","_React$Component","props","_this","__proto__","Object","getPrototypeOf","call","onEnd","force","handle","state","removeDocumentEvents","onAfterChange","getValue","setState","count","min","max","initialValue","Array","apply","undefined","map","defaultValue","value","bounds","v","i","trimAlignValue","recent","length","key","componentWillReceiveProps","nextProps","_this2","nextBounds","every","some","isValueOutOfRange","newValues","ensureValueInRange","onChange","isNotControlled","controlledState","forEach","item","keys","data","changedValue","onStart","position","onBeforeChange","calcValueByPos","startValue","startPosition","closestBound","getClosestBound","prevMovedHandleIndex","getBoundNeedMoving","prevValue","concat","onMove","e","pauseEvent","oldValue","moveTo","onKeyboard","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","Math","abs","_state","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","_props","marks","step","cache","_getPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushable","pushSurroundingHandles","allowCross","indexOf","handlesRefs","focus","threshold","Number","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","arguments","mergedProps","valInRange","valNotConflict","ensureValueNotConflict","ensureValuePrecision","val","_ref","thershold","render","_this4","_state2","_props2","prefixCls","vertical","included","disabled","handleGenerator","trackStyle","handleStyle","tabIndex","offsets","calcOffset","handleClassName","handles","_classNames","_tabIndex","className","offset","dragging","index","style","ref","h","saveHandle","tracks","slice","_","_classNames2","trackClassName","createElement","Component","displayName","propTypes","autoFocus","bool","arrayOf","number","oneOfType","defaultProps"],"mappings":"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","sourcesContent":["import _defineProperty from 'babel-runtime/helpers/defineProperty';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* eslint-disable react/prop-types */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar Range = function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  function Range(props) {\n    _classCallCheck(this, Range);\n\n    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, props));\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _this.trimAlignValue(v, i);\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n\n  _createClass(Range, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n\n      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;\n      if (this.props.min === nextProps.min && this.props.max === nextProps.max && shallowEqual(this.props.value, nextProps.value)) {\n        return;\n      }\n\n      var bounds = this.state.bounds;\n\n      var value = nextProps.value || bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _this2.trimAlignValue(v, i, nextProps);\n      });\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\n        return v === bounds[i];\n      })) return;\n\n      this.setState({ bounds: nextBounds });\n\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, nextProps);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, nextProps);\n        });\n        this.props.onChange(newValues);\n      }\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends({}, this.state, state);\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: 'onStart',\n    value: function onStart(position) {\n      var props = this.props;\n      var state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({ bounds: nextBounds });\n    }\n  }, {\n    key: 'onMove',\n    value: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var state = this.state;\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n\n      this.moveTo(value);\n    }\n  }, {\n    key: 'onKeyboard',\n    value: function onKeyboard(e) {\n      var valueMutator = utils.getKeyboardValueMutator(e);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n        var value = this.trimAlignValue(mutatedValue);\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: 'getClosestBound',\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    }\n  }, {\n    key: 'getBoundNeedMoving',\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _state = this.state,\n          bounds = _state.bounds,\n          recent = _state.recent;\n\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    }\n  }, {\n    key: 'getLowerBound',\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: 'getUpperBound',\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n\n      return bounds[bounds.length - 1];\n    }\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: 'getPoints',\n    value: function getPoints() {\n      var _props = this.props,\n          marks = _props.marks,\n          step = _props.step,\n          min = _props.min,\n          max = _props.max;\n\n      var cache = this._getPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = { marks: marks, step: step, points: points };\n      }\n      return this._getPointsCache.points;\n    }\n  }, {\n    key: 'moveTo',\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: 'pushSurroundingHandles',\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.props.pushable;\n\n      threshold = Number(threshold);\n\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: 'pushHandle',\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    }\n  }, {\n    key: 'pushHandleOnePoint',\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.props.pushable;\n\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: 'trimAlignValue',\n    value: function trimAlignValue(v, handle) {\n      var nextProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var mergedProps = _extends({}, this.props, nextProps);\n      var valInRange = utils.ensureValueInRange(v, mergedProps);\n      var valNotConflict = this.ensureValueNotConflict(handle, valInRange, mergedProps);\n      return utils.ensureValuePrecision(valNotConflict, mergedProps);\n    }\n  }, {\n    key: 'ensureValueNotConflict',\n    value: function ensureValueNotConflict(handle, val, _ref) {\n      var allowCross = _ref.allowCross,\n          thershold = _ref.pushable;\n\n      var state = this.state || {};\n      var bounds = state.bounds;\n\n      handle = handle === undefined ? state.handle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var _state2 = this.state,\n          handle = _state2.handle,\n          bounds = _state2.bounds;\n      var _props2 = this.props,\n          prefixCls = _props2.prefixCls,\n          vertical = _props2.vertical,\n          included = _props2.included,\n          disabled = _props2.disabled,\n          min = _props2.min,\n          max = _props2.max,\n          handleGenerator = _props2.handle,\n          trackStyle = _props2.trackStyle,\n          handleStyle = _props2.handleStyle,\n          tabIndex = _props2.tabIndex;\n\n\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n\n      var handleClassName = prefixCls + '-handle';\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var _tabIndex = tabIndex[i] || 0;\n        if (disabled || tabIndex[i] === null) {\n          _tabIndex = null;\n        }\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, handleClassName + '-' + (i + 1), true), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: handle === i,\n          index: i,\n          tabIndex: _tabIndex,\n          min: min,\n          max: max,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          }\n        });\n      });\n\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, prefixCls + '-track', true), _defineProperty(_classNames2, prefixCls + '-track-' + i, true), _classNames2));\n        return React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n\n      return { tracks: tracks, handles: handles };\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n\nRange.displayName = 'Range';\nRange.propTypes = {\n  autoFocus: PropTypes.bool,\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  allowCross: PropTypes.bool,\n  disabled: PropTypes.bool,\n  tabIndex: PropTypes.arrayOf(PropTypes.number),\n  min: PropTypes.number,\n  max: PropTypes.number\n};\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  tabIndex: []\n};\n\n\nexport default createSlider(Range);"]},"metadata":{},"sourceType":"module"}